//go:build ignore

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type StructInfo struct {
	Name   string
	Fields []FieldInfo
}

type FieldInfo struct {
	Name     string
	Type     string
	JSONTag  string
	Comments string
}

type EnumInfo struct {
	Name   string
	Values []string
}

const modelTemplate = `// Code generated by generate_domain_models.go.
// This file is generated from the sqlc models.go file for developers convinience.
// Check the sqlc models.go file for the source of truth.

package models

import (
	"time"
	"github.com/google/uuid"
)

// {{.Name}} represents the domain model for {{.Name}}
type {{.Name}} struct {
{{range .Fields}}	{{.Name}} {{.Type}} {{.JSONTag}}{{if .Comments}} // {{.Comments}}{{end}}
{{end}}}

// Create{{.Name}}Params represents parameters for creating a {{.Name}}
type Create{{.Name}}Params struct {
{{range .Fields}}{{if and (ne .Name "ID") (ne .Name "CreatedAt") (ne .Name "UpdatedAt")}}	{{.Name}} {{.Type}} {{.JSONTag}}{{if .Comments}} // {{.Comments}}{{end}}
{{end}}{{end}}}

// Update{{.Name}}Params represents parameters for updating a {{.Name}}
type Update{{.Name}}Params struct {
	ID {{(index .Fields 0).Type}} {{(index .Fields 0).JSONTag}} // Primary key
{{range .Fields}}{{if and (ne .Name "ID") (ne .Name "CreatedAt") (ne .Name "UpdatedAt")}}	{{.Name}} *{{.Type}} {{.JSONTag}}{{if .Comments}} // Optional for updates{{end}}
{{end}}{{end}}}
`

const enumsTemplate = `// Code generated by generate_domain_models.go. DO NOT EDIT.
// In case of editing this file please make sure of consistency
// If you have to change the template, please update the template in the scripts/generate_domain_models.go file.

package models

// Domain enum types copied from sqlc models
{{range .Enums}}
type {{.Name}} string

const (
{{range .Values}}	{{.}}
{{end}})
{{end}}
`

func main() {
	sqlcDir := "internal/db/sqlc"
	domainDir := "internal/domain/models"

	// Parse sqlc models
	structs, enums, err := parseSqlcModels(sqlcDir + "/models.go")
	if err != nil {
		fmt.Printf("Error parsing sqlc models: %v\n", err)
		os.Exit(1)
	}

	// Filter out enum wrapper types (Null* types) and only keep actual domain entities
	filteredStructs := filterDomainEntities(structs)

	// Clean up old generated files
	err = cleanupOldFiles(domainDir)
	if err != nil {
		fmt.Printf("Error cleaning up old files: %v\n", err)
		os.Exit(1)
	}

	// Generate enum definitions file
	err = generateEnumsFile(enums, domainDir+"/enums.go")
	if err != nil {
		fmt.Printf("Error generating enums file: %v\n", err)
		os.Exit(1)
	}

	// Generate separate files for each domain model
	for _, structInfo := range filteredStructs {
		filename := strings.ToLower(structInfo.Name) + ".go"
		err = generateModelFile(structInfo, domainDir+"/"+filename)
		if err != nil {
			fmt.Printf("Error generating model file for %s: %v\n", structInfo.Name, err)
			os.Exit(1)
		}
	}

	fmt.Printf("Generated %d domain models and %d enums\n", len(filteredStructs), len(enums))
}

func parseSqlcModels(filePath string) ([]StructInfo, []EnumInfo, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return nil, nil, err
	}

	var structs []StructInfo
	var enums []EnumInfo

	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.TypeSpec:
			if structType, ok := x.Type.(*ast.StructType); ok {
				structInfo := StructInfo{
					Name:   x.Name.Name,
					Fields: parseFields(structType),
				}
				structs = append(structs, structInfo)
			} else if _, ok := x.Type.(*ast.Ident); ok && strings.HasSuffix(x.Name.Name, "Enum") && !strings.HasPrefix(x.Name.Name, "Null") {
				// Parse enum type
				enumInfo := EnumInfo{
					Name: x.Name.Name,
				}
				enums = append(enums, enumInfo)
			}
		case *ast.GenDecl:
			// Parse const declarations for enum values
			if x.Tok == token.CONST {
				for _, spec := range x.Specs {
					if valueSpec, ok := spec.(*ast.ValueSpec); ok {
						for i, name := range valueSpec.Names {
							if len(enums) > 0 {
								// Find the enum this constant belongs to
								for j := range enums {
									if strings.HasPrefix(name.Name, enums[j].Name) {
										if i < len(valueSpec.Values) {
											if basicLit, ok := valueSpec.Values[i].(*ast.BasicLit); ok {
												enumValue := fmt.Sprintf("%s %s = %s", name.Name, enums[j].Name, basicLit.Value)
												enums[j].Values = append(enums[j].Values, enumValue)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return true
	})

	return structs, enums, nil
}

func parseFields(structType *ast.StructType) []FieldInfo {
	var fields []FieldInfo

	for _, field := range structType.Fields.List {
		for _, name := range field.Names {
			fieldType := getFieldType(field.Type)
			jsonTag := getJSONTag(field.Tag)
			convertedType := convertType(fieldType)

			fields = append(fields, FieldInfo{
				Name:    name.Name,
				Type:    convertedType,
				JSONTag: jsonTag,
			})
		}
	}

	return fields
}

func getFieldType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return fmt.Sprintf("%s.%s", getFieldType(t.X), t.Sel.Name)
	case *ast.ArrayType:
		// Handle []byte and other array types
		elemType := getFieldType(t.Elt)
		return "[]" + elemType
	default:
		return "interface{}"
	}
}

// convertType converts the sqlc type (Postgres types) to the domain type
// The Domain layer should not depend on the Postgres implementation
func convertType(sqlcType string) string {
	conversions := map[string]string{
		"pgtype.UUID":        "uuid.UUID",
		"pgtype.Timestamptz": "time.Time",
		"pgtype.Numeric":     "float32",
		"string":             "string",
		"int32":              "int32",
		"int64":              "int64",
		"bool":               "bool",
		"[]byte":             "interface{}", // For JSON data fields
	}

	if converted, ok := conversions[sqlcType]; ok {
		return converted
	}
	return sqlcType
}

func getJSONTag(tag *ast.BasicLit) string {
	if tag == nil {
		return ""
	}

	tagStr := tag.Value
	tagStr = strings.Trim(tagStr, "`")

	// Extract json tag
	parts := strings.Split(tagStr, " ")
	for _, part := range parts {
		if strings.HasPrefix(part, "json:") {
			return "`" + part + "`"
		}
	}

	return ""
}

// filterDomainEntities filters out enum wrapper types and returns only actual domain entities
func filterDomainEntities(structs []StructInfo) []StructInfo {
	var filteredStructs []StructInfo
	for _, s := range structs {
		// Skip enum wrapper types (Null* types) and only keep actual domain entities
		if !strings.HasPrefix(s.Name, "Null") {
			filteredStructs = append(filteredStructs, s)
		}
	}
	return filteredStructs
}

// cleanupOldFiles removes old generated files
func cleanupOldFiles(domainDir string) error {
	// Remove the old generated_models.go file if it exists
	oldFile := filepath.Join(domainDir, "generated_models.go")
	if _, err := os.Stat(oldFile); err == nil {
		if err := os.Remove(oldFile); err != nil {
			return fmt.Errorf("failed to remove old generated_models.go: %w", err)
		}
	}
	return nil
}

// generateEnumsFile generates the enums.go file with all enum definitions
func generateEnumsFile(enums []EnumInfo, outputPath string) error {
	// Create domain directory if it doesn't exist
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}

	tmpl, err := template.New("enums").Parse(enumsTemplate)
	if err != nil {
		return err
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	data := struct {
		Enums []EnumInfo
	}{
		Enums: enums,
	}

	return tmpl.Execute(file, data)
}

// generateModelFile generates a separate file for each domain model
func generateModelFile(structInfo StructInfo, outputPath string) error {
	// Create domain directory if it doesn't exist
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}

	tmpl, err := template.New("model").Parse(modelTemplate)
	if err != nil {
		return err
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	return tmpl.Execute(file, structInfo)
}
