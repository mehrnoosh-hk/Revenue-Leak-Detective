//go:build ignore

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type StructInfo struct {
	Name   string
	Fields []FieldInfo
}

type FieldInfo struct {
	Name        string
	Type        string
	JSONTag     string
	Comments    string
	ConvertFrom string
	ConvertTo   string
}

const domainTemplate = `// Code generated by generate_domain_models.go. DO NOT EDIT.

package models

import (
	"time"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	sqlc "rdl-api/internal/db/sqlc"
)

{{range .Structs}}
// {{.Name}} represents the domain model for {{.Name}}
type {{.Name}} struct {
{{range .Fields}}	{{.Name}} {{.Type}} {{.JSONTag}}{{if .Comments}} // {{.Comments}}{{end}}
{{end}}}

// To{{.Name}} converts sqlc.{{.Name}} to domain.{{.Name}}
func To{{.Name}}Domain(s sqlc.{{.Name}}) *{{.Name}} {
	return &{{.Name}}{
{{range .Fields}}		{{.Name}}: {{.ConvertFrom}},
{{end}}	}
}

// To{{.Name}}Sqlc converts domain.{{.Name}} to sqlc.{{.Name}}
func To{{.Name}}Sqlc(d *{{.Name}}) sqlc.{{.Name}} {
	return sqlc.{{.Name}}{
{{range .Fields}}		{{.Name}}: {{.ConvertTo}},
{{end}}	}
}

{{end}}

// Parameter structs for repository operations
{{range .Structs}}
// Create{{.Name}}Params represents parameters for creating a {{.Name}}
type Create{{.Name}}Params struct {
{{range .Fields}}{{if and (ne .Name "ID") (ne .Name "CreatedAt") (ne .Name "UpdatedAt")}}	{{.Name}} {{.Type}} {{.JSONTag}}{{if .Comments}} // {{.Comments}}{{end}}
{{end}}{{end}}}

// Update{{.Name}}Params represents parameters for updating a {{.Name}}
type Update{{.Name}}Params struct {
	ID {{(index .Fields 0).Type}} {{(index .Fields 0).JSONTag}} // Primary key
{{range .Fields}}{{if and (ne .Name "ID") (ne .Name "CreatedAt")}}	{{.Name}} *{{.Type}} {{.JSONTag}}{{if .Comments}} // Optional for updates{{end}}
{{end}}{{end}}}
{{end}}`

func main() {
	sqlcDir := "internal/db/sqlc"
	domainDir := "internal/domain/models"

	// Parse sqlc models
	structs, err := parseSqlcModels(sqlcDir + "/models.go")
	if err != nil {
		fmt.Printf("Error parsing sqlc models: %v\n", err)
		os.Exit(1)
	}

	// Generate domain models
	err = generateDomainModels(structs, domainDir+"/generated_models.go")
	if err != nil {
		fmt.Printf("Error generating domain models: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %d domain models\n", len(structs))
}

func parseSqlcModels(filePath string) ([]StructInfo, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var structs []StructInfo

	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.TypeSpec:
			if structType, ok := x.Type.(*ast.StructType); ok {
				structInfo := StructInfo{
					Name:   x.Name.Name,
					Fields: parseFields(structType),
				}
				structs = append(structs, structInfo)
			}
		}
		return true
	})

	return structs, nil
}

func parseFields(structType *ast.StructType) []FieldInfo {
	var fields []FieldInfo

	for _, field := range structType.Fields.List {
		for _, name := range field.Names {
			fieldType := getFieldType(field.Type)
			jsonTag := getJSONTag(field.Tag)
			convertedType := convertType(fieldType)

			fields = append(fields, FieldInfo{
				Name:        name.Name,
				Type:        convertedType,
				JSONTag:     jsonTag,
				ConvertFrom: getConvertFrom(fieldType, name.Name),
				ConvertTo:   getConvertTo(fieldType, name.Name),
			})
		}
	}

	return fields
}

func getFieldType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return fmt.Sprintf("%s.%s", getFieldType(t.X), t.Sel.Name)
	default:
		return "interface{}"
	}
}

func convertType(sqlcType string) string {
	conversions := map[string]string{
		"pgtype.UUID":        "uuid.UUID",
		"pgtype.Timestamptz": "time.Time",
		"string":             "string",
		"int32":              "int32",
		"int64":              "int64",
		"bool":               "bool",
	}

	if converted, ok := conversions[sqlcType]; ok {
		return converted
	}
	return sqlcType
}

func getJSONTag(tag *ast.BasicLit) string {
	if tag == nil {
		return ""
	}

	tagStr := tag.Value
	tagStr = strings.Trim(tagStr, "`")

	// Extract json tag
	parts := strings.Split(tagStr, " ")
	for _, part := range parts {
		if strings.HasPrefix(part, "json:") {
			return "`" + part + "`"
		}
	}

	return ""
}

// getConvertFrom converts the sqlc pgtype type to the domain type
func getConvertFrom(sqlcType, fieldName string) string {
	switch sqlcType {
	case "pgtype.UUID":
		return fmt.Sprintf("s.%s.Bytes", fieldName)
	case "pgtype.Timestamptz":
		return fmt.Sprintf("s.%s.Time", fieldName)
	default:
		return fmt.Sprintf("s.%s", fieldName)
	}
}

// getConvertTo converts the domain type to the sqlc pgtype type
func getConvertTo(sqlcType, fieldName string) string {
	switch sqlcType {
	case "pgtype.UUID":
		return fmt.Sprintf("pgtype.UUID{Bytes: d.%s, Valid: true}", fieldName)
	case "pgtype.Timestamptz":
		return fmt.Sprintf("pgtype.Timestamptz{Time: d.%s, Valid: true}", fieldName)
	default:
		return fmt.Sprintf("d.%s", fieldName)
	}
}

// generateDomainModels generates the domain models
func generateDomainModels(structs []StructInfo, outputPath string) error {
	// Create domain directory if it doesn't exist
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}

	tmpl, err := template.New("domain").Parse(domainTemplate)
	if err != nil {
		return err
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	data := struct {
		Structs []StructInfo
	}{
		Structs: structs,
	}

	return tmpl.Execute(file, data)
}
